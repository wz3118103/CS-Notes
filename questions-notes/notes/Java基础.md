# 1.Java基础知识

包括：
* 类型、值和变量
* 表达式
* 语句


Q.字符型常量和字符串常量的区别
* 形式上: 字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
* 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)
* 占内存大小：字符常量只占 2 个字节；字符串常量占若干个字节(至少一个字符结束标志) (注意： char 在 Java 中占两个字节)


Q.String、StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？
* 可变性
  - 简单的来说：String 类中使用 final 关键字字符数组保存字符串，private final char value[]，所以 String 对象是不可变的。
  - 而StringBuilder 与StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder    中也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。
  - StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的
* 线程安全性
  - String 中的对象是不可变的，也就可以理解为常量，线程安全。
  - AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。
* 性能
  - 每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象
  - StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
* 对于三者使用的总结：
  - 操作少量的数据 = String
  - 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
  - 多线程操作字符串缓冲区下操作大量数据 = StringBuffer


Q.自动装箱与拆箱
* 装箱：将基本类型用它们对应的引用类型包装起来；
* 拆箱：将包装类型转换为基本数据类型；


Q.final finally finalize
* final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
* finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
* finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

# 2.面向对象

包括：
* 对象与类
* 继承
* 反射

Q.构造器 Constructor 是否可被 override
* 在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。


Q. 重载和重写的区别
* 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
* 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。


Q.Java 面向对象编程三大特性: 封装 继承 多态
* 封装
  封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
* 继承
  继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
  关于继承如下3点请记住：
  - 子类拥有父类非 private 的属性和方法。
  - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
* 多态
  所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

Q.在一个静态方法内调用一个非静态成员为什么是非法的
* 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。


Q.在 Java中定义一个不做事且没有参数的构造方法的作用
* Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

Q.import java 和 javax 有什么区别
* 刚开始的时候 JavaAPI 所必需的包是java开头的包，javax当时只是扩展API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。
所以，实际上 java 和 javax 没有区别。这都是一个名字。

Q. 接口和抽象类的区别是什么
* 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法
* 接口中的实例变量默认是 final 类型的，而抽象类中则不一定
* 一个类可以实现多个接口，但最多只能实现一个抽象类
* 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
* 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

Q.成员变量与局部变量的区别有那些
* 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员
变量和局部变量都能被 final 所修饰；
* 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存
* 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
* 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。


Q.创建一个对象用什么运算符?对象实体与对象引用有何不同?
* new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象;一个对象可以有 n 个引用指向它。


Q.一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?
* 主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。


Q.静态方法和实例方法有何不同
* 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
* 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制


Q.对象的相等与指向他们的引用相等，两者有什么不同？
* 对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。


Q.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?
* 帮助子类做初始化工作。

Q.== 与 equals(重要)
* == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
* equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
  - 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
  - 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。
* String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
* 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。


Q.hashCode 与 equals（重要），面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals时必须重写 hashCode 方法？”
* hashCode（）介绍
  hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）
* 为什么要有 hashCode
  我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。
* hashCode（）与 equals（）的相关规定
  - 如果两个对象相等，则 hashcode 一定也是相同的
  - 两个对象相等,对两个对象分别调用 equals 方法都返回 true
  - 两个对象有相同的 hashcode 值，它们也不一定是相等的
  - 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
  - hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）


Q.为什么 Java 中只有值传递
* Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。
* 实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。
* Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用



Q.关于 final 关键字的一些总结
* final 关键字主要用在三个地方：变量、方法、类。
* 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
* 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为final 方法。
* 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。


Q.对象的四种引用
* 强引用只要引用存在，垃圾回收器永远不会回收
可直接通过obj取得对应的对象。只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
* 软引用非必须引用，内存溢出之前进行回收
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
* 弱引用第二次垃圾回收时回收
弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，
将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的
isEnQueued方法返回对象是否被垃圾回收器标记。ThreadLocal中有使用到弱引用。
* 虚引用垃圾回收时回收，无法通过引用取到对象值
虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引
用。虚引用主要用于检测对象是否已经从内存中删除。



Q.Java获取反射的三种方法
* 通过new对象实现反射机制
* 通过路径实现反射机制
* 通过类名实现反射机制


Q.Java反射机制
* Java反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为Java的反射机
制。
* Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field,Method,Constructor类(每个类都实现了Member接口)。这些类型的对象时由JVM在运行时创建的，用以表示未知类里对应的成员。
* 这样你就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()getMethods()和getConstructors()等很便利的方法，以返回表示字段，方法，以及构造器的对象的数组。这样匿名对象的信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。

# 3.面向接口编程

包括：
* 接口
* lambda表达式
* 内部类
* 代理


Q.Cloneable接口实现原理
* Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例中，注意，这里所说的“拷贝”拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。
* 在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现Cloneable接口，并重写clone()方法，就可以通过调用clone()方法的方式简洁地实现实例拷贝功能
* 深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然Java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。
* 浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷
贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2中包含对C2（C1的copy）的引用。
* 若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝


# 4.异常、断言与日志

Q.Java 中的异常处理

<div align="center"> <img src="https://github.com/wz3118103/CS-Notes/blob/master/questions-notes/notes/pics/异常图.jpg" width="820px" > </div><br>

* 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。
* Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。
* Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和ArrayIndexOutOfBoundsException （下标越界异常）。
* 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。
* 异常处理总结
  - try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch块，则必须跟一个 finally 块。
  - catch 块：用于处理 try 捕获到的异常。
  - finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。
* 当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。
* 在以下 4 种特殊情况下，finally 块不会被执行：
  - 在 finally 语句块中发生了异常。
  - 在前面的代码中用了 System.exit()退出程序。
  - 程序所在的线程死亡。
  - 关闭 CPU。
* 总体上我们根据Javac对异常的处理要求，将异常类分为二类。
  - 非检查异常（unckeckedexception）：Error和RuntimeException以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。
  - 检查异常（checkedexception）：除了Error和RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException,IOException,ClassNotFoundException等。
  - 需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。


# 5.泛型

# 6.集合

Q.List和Set的区别
* List,Set都是继承自Collection接口
* List特点：元素有放入顺序，元素可重复
* Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set的Object必须定义equals()方法
* 另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）
* Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
* List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变

Q.HashSet是如何保证不重复的
* 向HashSet中add()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles方法比较。HashSet中的add()方法会使用HashMap的add()方法。HashMap的key是唯一的，HashSet添加进去的值就是作为HashMap的key。所以不会重复（HashMap比较key是否相等是先比较hashcode再比较equals）。

Q.HashMap是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?
* 不是线程安全的；
* 会产生哪些线程不安全的状况，参考《阿里那本书》

Q.HashMap的扩容过程
* 当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。
* 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更
多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法
是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。
* 如果cap是2的n次方，则容量为cap，否则为大于cap的第一个2的n次方的数。


Q.HashMap1.7与1.8的区别，说明1.8做了哪些优化，如何优化的？
* 在JDK1.7及之前的版本中，HashMap又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候，
就将对应节点以链表的形式存储。
* JDK1.8中，当同一个hash值（Table上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被
调整成一颗红黑树。这就是JDK7与JDK8中HashMap实现的最大区别。

Q.Arrays.sort和Collections.sort实现原理和区别
* Collection和Collections区别
  - java.util.Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
  - java.util.Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作。然后还有混排（Shuffling）、反转（Reverse）、替换所有的元素（fill）、拷贝（copy）、返回Collections中最小元素（min）、返回Collections中最大元素（max）、返回指定源列表中最后一次出现指定目标列表的起始位置（lastIndexOfSubList）、返回指定源列表中第一次出现指定目标列表的起始位置
（IndexOfSubList）、根据指定的距离循环移动指定列表中的元素（Rotate）。
* 事实上Collections.sort方法底层就是调用的array.sort方法，
* legacyMergeSort(a)：归并排序
  ComparableTimSort.sort()：Timsort排序
  Timsort排序是结合了合并排序（mergesort）和插入排序（insertionsort）而得出的排序算法
* Timsort的核心过程
  TimSort算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些run序列，每次拿一个run出来按规则进行合并。每次合并会将两个run合并成一个run。合并的结果保存到栈中。合并直到消耗掉所有的run，这时将栈上剩余的run合并到只剩一个run为止。这时这个仅剩的run便是排好序的结果。
* 综上述过程，Timsort算法的过程包括
（0）如何数组长度小于某个值，直接用二分插入排序算法
（1）找到各个run，并入栈
（2）按规则合并run


Q.LinkedHashMap的应用
* 基于LinkedHashMap的访问顺序的特点，可构造一个LRU（LeastRecentlyUsed）最近最少使用简单缓存。也有一些开源的缓存产品如ehcache的淘汰策略（LRU）就是在LinkedHashMap上扩展的。

# 7.注解

# 8.Java I/O

Q.Java 序列化中如果有些字段不想进行序列化，怎么办
* 对于不想进行序列化的变量，使用 transient 关键字修饰。
* transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

Q.获取用键盘输入常用的的两种方法
* 方法 1：通过 Scanner
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
* 方法 2：通过 BufferedReader
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();

# 9.类加载器

# 10.Stream






































